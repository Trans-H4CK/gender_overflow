require 'spec_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

describe AnswersController do
  let :question do
    mock_model(Question) do |q|
      q.stub(:id) { 1 }
    end
  end

  before do
    Question.should_receive(:find).with('1').and_return(question)
  end

  describe "GET new" do
    before do
      @answer = mock_model(Answer)
      Answer.should_receive(:new).and_return(@answer)
    end

    context 'not authorized' do
      before do
        should_not_authorize(:new, @answer)
      end

      it "should not be authorized" do
        get :new, :question_id => question
        verify_authorization_unsuccessful
      end
    end

    context 'authorized' do
      before do
        @answer.should_receive(:question=).with(question)
        @answer.should_receive(:user=)
        should_authorize(:new, @answer)
      end

      it "assigns a new answer as @answer" do
        get :new, :question_id => question
        assigns(:answer).should == @answer
        assigns(:question).should == question
      end
    end
  end

  describe "GET edit" do
    before do
      @answer = mock(Answer).tap do |q|
        q.stub(:id) { 1 }
      end
      Answer.should_receive(:find).with('1').and_return(@answer)
    end

    context 'not authorized' do
      before do
        should_not_authorize(:edit, @answer)
      end

      it "should not be authorized" do
        get :edit, :question_id => question, :id => @answer.id
        verify_authorization_unsuccessful
      end
    end

    context 'authorized' do
      before do
        should_authorize(:edit, @answer)
      end

      it "assigns given answer as @answer" do
        get :edit, :question_id => question, :id => @answer.id
        assigns(:answer).should == @answer
        assigns(:question).should == question
      end
    end
  end

  describe "POST create" do
    let :params do
      {
      :answer => "What's up?"
      }
    end

    before do
      answer.should_receive(:user=)
      answer.should_receive(:question=)
      Answer.should_receive(:new).with(params.with_indifferent_access).and_return(answer)
    end

    context 'authorized' do
      before do
        should_authorize(:create, answer)
        post :create, :question_id => question, :answer => params
      end

      context "with valid params" do

        let :answer do
          mock_model(Answer).tap do |q|
            q.stub(:save) { true }
            q.stub(:id) { 1 }
          end
        end

        it "should notify success on create" do
          flash[:notice].should == 'Answer was successfully created.'
        end

        it "redirects to the created answer" do
          response.should redirect_to(question_path(question))
        end
      end

      describe "with invalid params" do

        let :answer do
          mock_model(Answer).tap do |q|
            q.stub(:save) { false }
          end
        end

        it "redirects to the created answer" do
          response.should render_template(:new)
        end
      end
    end

    context "not authorized" do
      before do
        should_not_authorize(:create, answer)
        post :create, :question_id => question, :answer => params
      end

      let :answer do
        mock_model(Answer)
      end

      it "should notify success on create" do
        verify_authorization_unsuccessful
      end
    end
  end

  describe "PUT update" do
    let :params do
      {
      :answer => "What's up?"
      }
    end

    before do
      Answer.should_receive(:find).with('1').and_return(answer)
    end

    context 'authorized' do
      before do
        should_authorize(:update, answer)
        put :update, :question_id => question, :id => answer.id, :answer => params
      end

      describe "with valid params" do
        let :answer do
          mock_model(Answer).tap do |q|
            q.stub(:id) { 1 }
            q.stub(:update) { true }
          end
        end

        it "should notify success on create" do
          flash[:notice].should == 'Answer was successfully updated.'
        end

        it "redirects to the created answer" do
          response.should redirect_to(question_path(question))
        end
      end

      describe "with invalid params" do
        let :answer do
          mock_model(Answer).tap do |q|
            q.stub(:id) { 1 }
            q.stub(:update) { false }
          end
        end

        it "redirects to the created answer" do
          response.should render_template(:edit)
        end
      end
    end

    context "not authorized" do
      before do
        should_not_authorize(:update, answer)
        put :update, :question_id => question, :id => answer.id, :answer => params
      end

      let :answer do
        mock_model(Answer).tap do |q|
          q.stub(:id) { 1 }
        end
      end

      it "should notify success on create" do
        verify_authorization_unsuccessful
      end
    end

  end

  describe "DELETE destroy" do
    let :answer do
      mock_model(Answer).tap do |q|
        q.stub(:id) { 1 }
      end
    end

    before do
      Answer.should_receive(:find).with('1').and_return(answer)
    end

    context 'note authorized' do
      before do
        should_not_authorize(:destroy, answer)
        delete :destroy, :question_id => question, :id => answer.id
      end

      it "should not be authorized" do
        verify_authorization_unsuccessful
      end
    end

    context 'authorized' do
      before do
        should_authorize(:destroy, answer)
        answer.should_receive(:destroy)
        delete :destroy, :question_id => question, :id => answer.id
      end

      it "should let you know answer was deleted" do
        flash[:notice] == 'Answer was successfully destroyed.'
      end

      it "should return to the index" do
        response.should redirect_to question_path(question)
      end
    end

  end

  describe 'voting' do
    let :answer do
      mock_model(Answer).tap do |q|
        q.stub(:id) { 1 }
      end
    end

    before do
      Answer.should_receive(:find).with('1').and_return(answer)
    end

    describe 'not authorized' do
      before do
        should_not_authorize(:vote, answer)
      end

      it "up vote" do
        post :up_vote, :question_id => question, :id => answer.id
        verify_authorization_unsuccessful
      end

      it "down vote" do
        post :down_vote, :question_id => question, :id => answer.id
        verify_authorization_unsuccessful
      end

      it "switch vote" do
        put :switch_vote, :question_id => question, :id => answer.id
        verify_authorization_unsuccessful
      end

      it "delete vote" do
        delete :delete_vote, :question_id => question, :id => answer.id
        verify_authorization_unsuccessful
      end
    end

    context 'authorized' do
      before do
        should_authorize(:vote, answer)
      end

      context 'up_vote' do
        context 'success' do
          before do
            answer.should_receive(:up_vote).and_return(true)
            post :up_vote, :question_id => question, :id => answer.id
          end

          it "should let you know answer was deleted" do
            flash[:notice] == 'Answer was up voted!'
          end

          it "should return to the index" do
            response.should redirect_to question_path(question)
          end
        end

        context 'failure' do
          before do
            answer.should_receive(:up_vote).and_return(false)
            answer.stub_chain(:errors, :full_messages) { ["Failure"] }
            post :up_vote, :question_id => question, :id => answer.id
          end

          it "should let you know failure" do
            flash[:error].should == 'Failure'
          end

          it "should return to the index" do
            response.should redirect_to question_path(question)
          end
        end
      end

      context 'down_vote' do
        context 'success' do
          before do
            answer.should_receive(:down_vote).and_return(true)
            post :down_vote, :question_id => question, :id => answer.id
          end

          it "should let you know answer was deleted" do
            flash[:notice] == 'Answer was down voted!'
          end

          it "should return to the index" do
            response.should redirect_to question_path(question)
          end
        end

        context 'failure' do
          before do
            answer.should_receive(:down_vote).and_return(false)
            answer.stub_chain(:errors, :full_messages) { ["Failure"]}
            post :down_vote, :question_id => question, :id => answer.id
          end

          it "should let you know failure" do
            flash[:error].should == 'Failure'
          end

          it "should return to the index" do
            response.should redirect_to question_path(question)
          end
        end
      end

      context 'switch_vote' do
        context 'success' do
          before do
            answer.should_receive(:switch_vote).and_return(true)
            put :switch_vote, :question_id => question, :id => answer.id
          end

          it "should let you know answer was deleted" do
            flash[:notice] == 'Your vote was switched!'
          end

          it "should return to the index" do
            response.should redirect_to question_path(question)
          end
        end
      end

      context 'delete_vote' do
        context 'success' do
          before do
            answer.should_receive(:delete_vote).and_return(true)
            delete :delete_vote, :question_id => question, :id => answer.id
          end

          it "should let you know answer was deleted" do
            flash[:notice] == 'Vote removed!'
          end

          it "should return to the index" do
            response.should redirect_to question_path(question)
          end
        end
      end
    end
  end
end
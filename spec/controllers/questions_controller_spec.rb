require 'spec_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

describe QuestionsController do

  describe "GET index" do
    before do
      @question = mock(Question)
      Question.should_receive(:accessible_by).and_return([@question])
      should_authorize(:index, Question)
    end

    it "assigns all questions as @questions" do
      get :index
      assigns(:questions).should eq([@question])
    end
  end

  describe "GET show" do
    before do
      @question = mock_model(Question) do |q|
        q.stub(:id) { '1' }
      end
      should_authorize(:show, @question)
      Question.should_receive(:find).with('1').and_return(@question)
    end

    it "assigns the requested question as @question" do
      get :show, :id => @question.id
      assigns(:question).should eq(@question)
    end
  end

  describe "GET new" do
    before do
      @question = mock_model(Question)
      Question.should_receive(:new).and_return(@question)
    end

    context 'not authorized' do
      before do
        should_not_authorize(:new, @question)
      end

      it "should not be authorized" do
        get :new
        verify_authorization_unsuccessful
      end
    end

    context 'authorized' do
      before do
        @question.should_receive(:user=)
        should_authorize(:new, @question)
      end

      it "assigns a new question as @question" do
        get :new
        assigns(:question).should == @question
      end
    end
  end

  describe "GET edit" do
    before do
      @question = mock(Question).tap do |q|
        q.stub(:id) { 1 }
      end
      Question.should_receive(:find).with('1').and_return(@question)
    end

    context 'not authorized' do
      before do
        should_not_authorize(:edit, @question)
      end

      it "should not be authorized" do
        get :edit, :id => @question.id
        verify_authorization_unsuccessful
      end
    end

    context 'authorized' do
      before do
        should_authorize(:edit, @question)
      end

      it "assigns given question as @question" do
        get :edit, :id => @question.id
        assigns(:question).should == @question
      end
    end
  end

  describe "POST create" do
    let :params do
      {
      :question => "What's up?"
      }
    end

    before do
      question.should_receive(:user=)
      Question.should_receive(:new).with(params.with_indifferent_access).and_return(question)
    end

    context 'authorized' do
      before do
        should_authorize(:create, question)
        post :create, :question => params
      end

      context "with valid params" do

        let :question do
          mock_model(Question).tap do |q|
            q.stub(:save) { true }
            q.stub(:id) { 1 }
          end
        end

        it "should notify success on create" do
          flash[:notice].should == 'Question was successfully created.'
        end

        it "redirects to the created question" do
          response.should redirect_to(question_path(1))
        end
      end

      describe "with invalid params" do

        let :question do
          mock_model(Question).tap do |q|
            q.stub(:save) { false }
          end
        end

        it "redirects to the created question" do
          response.should render_template(:new)
        end
      end
    end

    context "not authorized" do
      before do
        should_not_authorize(:create, question)
        post :create, :question => params
      end

      let :question do
        mock_model(Question)
      end

      it "should notify success on create" do
        verify_authorization_unsuccessful
      end
    end
  end

  describe "PUT update" do
    let :params do
      {
      :question => "What's up?"
      }
    end

    before do
      Question.should_receive(:find).with('1').and_return(question)
    end

    context 'authorized' do
      before do
        should_authorize(:update, question)
        put :update, :id => question.id, :question => params
      end

      describe "with valid params" do
        let :question do
          mock_model(Question).tap do |q|
            q.stub(:id) { 1 }
            q.stub(:update) { true }
          end
        end

        it "should notify success on create" do
          flash[:notice].should == 'Question was successfully updated.'
        end

        it "redirects to the created question" do
          response.should redirect_to(question_path(1))
        end
      end

      describe "with invalid params" do
        let :question do
          mock_model(Question).tap do |q|
            q.stub(:id) { 1 }
            q.stub(:update) { false }
          end
        end

        it "redirects to the created question" do
          response.should render_template(:edit)
        end
      end
    end

    context "not authorized" do
      before do
        should_not_authorize(:update, question)
        put :update, :id => question.id, :question => params
      end

      let :question do
        mock_model(Question).tap do |q|
          q.stub(:id) { 1 }
        end
      end

      it "should notify success on create" do
        verify_authorization_unsuccessful
      end
    end

  end

  describe "DELETE destroy" do
    let :question do
      mock_model(Question).tap do |q|
        q.stub(:id) { 1 }
      end
    end

    before do
      Question.should_receive(:find).with('1').and_return(question)
    end

    context 'authorized' do
      before do
        should_not_authorize(:destroy, question)
        delete :destroy, :id => question.id
      end

      it "should not be authorized" do
        verify_authorization_unsuccessful
      end
    end

    context 'authorized' do
      before do
        should_authorize(:destroy, question)
        question.should_receive(:destroy)
        delete :destroy, :id => question.id
      end

      it "should let you know question was deleted" do
        flash[:notice] == 'Question was successfully destroyed.'
      end

      it "should return to the index" do
        response.should redirect_to questions_path
      end
    end

    context 'authorized' do
      before do
        should_not_authorize(:destroy, question)
        delete :destroy, :id => question.id
      end

      it "should let you know question was deleted" do
        verify_authorization_unsuccessful
      end
    end
  end

end
